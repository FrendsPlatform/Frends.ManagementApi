#pragma warning disable SA1503 // Braces should not be omitted
namespace Frends.ManagementApi.Request;

using Frends.ManagementApi.Request.Definitions;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// Frends Management API Task.
/// </summary>
public static class ManagementApi
{
    /// <summary>
    /// Task for reading data from Frends Management API.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.ManagementApi.Request).
    /// </summary>
    /// <param name="input">Input parameters.</param>
    /// <param name="options">Option parameters.</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool Success, dynamic Data, dynamic ErrorMessage }.</returns>
    public static async Task<Result> Request([PropertyTab] Input input, [PropertyTab] Options options, CancellationToken cancellationToken)
    {
        InputChecker(input);
        var headers = GetHeaderDictionary(input);
        var hbody = string.Empty;
        try
        {
            var url = new Uri($"{input.TenantUrl}/api/{input.ManagementApiVersion}/{input.Path}");
            using var responseMessage = await GetHttpRequestResponseAsync(input.Method.ToString(), url, headers, cancellationToken);
            hbody = await responseMessage.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
            var hstatusCode = (int)responseMessage.StatusCode;

            if (hstatusCode != 200)
            {
                if (options.ThrowExceptionOnError)
                    throw new Exception(hbody);
                else
                    return new Result(false, null, hbody);
            }

            return new Result(true, hbody, null);
        }
        catch (Exception ex)
        {
            if (options.ThrowExceptionOnError)
                throw;
            return new Result(false, hbody, ex);
        }
    }

    private static void InputChecker(Input input)
    {
        if (string.IsNullOrEmpty(input.TenantUrl))
            throw new ArgumentNullException(nameof(input.TenantUrl) + " cannot be empty.");
        if (string.IsNullOrEmpty(input.ManagementApiVersion))
            throw new ArgumentNullException(nameof(input.ManagementApiVersion) + " cannot be empty.");
    }

    private static IDictionary<string, string> GetHeaderDictionary(Input inputs)
    {
        var authHeader = new Header
        {
            Name = "Authorization",
            Value = $"Bearer {inputs.Token}",
        };
        var acceptHeader = new Header
        {
            Name = "Accept",
            Value = $"application/json",
        };
        var headers = new[] { authHeader, acceptHeader }.ToArray();

        // Ignore case for headers and key comparison
        return headers.ToDictionary(key => key.Name, value => value.Value, StringComparer.InvariantCultureIgnoreCase);
    }

    private static async Task<HttpResponseMessage> GetHttpRequestResponseAsync(string method, Uri url, IDictionary<string, string> headers, CancellationToken cancellationToken)
    {
        HttpResponseMessage response;
        cancellationToken.ThrowIfCancellationRequested();
        using var httpClient = new HttpClient();
        using var request = new HttpRequestMessage(new HttpMethod(method), url);

        foreach (var header in headers)
            request.Headers.TryAddWithoutValidation(header.Key, header.Value);

        try
        {
            response = await httpClient.SendAsync(request, cancellationToken).ConfigureAwait(false);
        }
        catch (TaskCanceledException canceledException)
        {
            if (cancellationToken.IsCancellationRequested)
                throw; // Cancellation is from outside -> Just throw
            throw new Exception("HttpRequest was canceled, most likely due to a timeout.", canceledException); // Cancellation is from inside of the request, mostly likely a timeout
        }

        return response;
    }
}